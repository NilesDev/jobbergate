import copy
import pathlib
import typing

import typer
import yaml

from jobbergate_cli.constants import (
    SortOrder,
    JOBBERGATE_APPLICATION_CONFIG,
    JOBBERGATE_APPLICATION_CONFIG_FILE_NAME,
    JOBBERGATE_APPLICATION_MODULE_FILE_NAME,
)
from jobbergate_cli.exceptions import Abort, handle_abort
from jobbergate_cli.schemas import JobbergateContext, ListResponseEnvelope
from jobbergate_cli.render import StyleMapper, render_list_results, render_single_result
from jobbergate_cli.requests import make_request
from jobbergate_cli.subapps.applications.file_tools import validate_application_files, find_templates, dump_full_config


# move hidden field logic to the API
HIDDEN_FIELDS = [
    "application_config",
    "application_file",
    "created_at",
    "updated_at",
]

ID_NOTE = """

    This id represents the primary key of the application in the database. It
    will always be a unique integer and is automatically generated by the server
    when an Application is created. All applications receive an id, so it may
    be used to target a specific instance of an application whether or not it
    is provided with a human-friendly "identifier".
"""


IDENTIFIER_NOTE = """

    The identifier allows the user to access commonly used applications with a
    friendly name that is easy to remember. Identifiers should only be used
    for applications that are frequently used or should be easy to find in the list.
    An identifier may be added, removed, or changed on an existing application.
"""


style_mapper = StyleMapper(
    id = "green",
    application_name = "cyan",
    application_identifier = "magenta",
)


app = typer.Typer(
    help="Commands to interact with applications",
)


@app.command()
@handle_abort
def list_all(
    ctx: typer.Context,
    show_all: bool = typer.Option(False, "--all", help="Show all applications, even the ones without identifier"),
    user_only: bool = typer.Option(False, "--user", help="Show only applications owned by the current user"),
    search: typing.Optional[str] = typer.Option(None, help="Apply a search term to results"),
    sort_order: SortOrder = typer.Option(SortOrder.UNSORTED, help="Specify sort order"),
    sort_field: typing.Optional[str] = typer.Option(None, help="The field by which results should be sorted"),
):
    """
    Show available applications
    """
    jg_ctx: JobbergateContext = ctx.obj

    # Make static type checkers happy
    assert jg_ctx is not None
    assert jg_ctx.client is not None

    params: typing.Dict[str, typing.Any] = dict(
        all=show_all,
        user=user_only,
    )
    if search is not None:
        params["search"] = search
    if sort_order is not SortOrder.UNSORTED:
        params["sort_ascending"] = SortOrder is SortOrder.ASCENDING
    if sort_field is not None:
        params["sort_field"] = sort_field


    envelope = typing.cast(ListResponseEnvelope, make_request(
        jg_ctx.client,
        "/applications",
        "GET",
        expected_status=200,
        abort_message="Couldn't retrieve applications list from API",
        support=True,
        response_model=ListResponseEnvelope,
        data=params,
    ))
    render_list_results(
        jg_ctx,
        envelope,
        title="Applications List",
        style_mapper=style_mapper,
        hidden_fields=HIDDEN_FIELDS,
    )


@app.command()
@handle_abort
def get_one(
    ctx: typer.Context,
    id: typing.Optional[int] = typer.Option(
        None,
        help=f"The specific id of the application. {ID_NOTE}",
    ),
    identifier: typing.Optional[str] = typer.Option(
        None,
        help=f"The human-friendly identifier of the application. {IDENTIFIER_NOTE}",
    ),
):
    """
    Get a single application by id or identifier
    """
    jg_ctx: JobbergateContext = ctx.obj
    url = f"/applications/{id}"
    params = dict()
    if id is None and identifier is None:
        raise Abort(
            """
            You must supply either [yellow]id[/yellow] or [yellow]identifier[/yellow].
            """,
            subject="INVALID PARAMS",
            warn_only=True,
        )
    elif id is not None and identifier is not None:
        raise Abort(
            """
            You may not supply both [yellow]id[/yellow] and [yellow]identifier[/yellow].
            """,
            subject="INVALID PARAMS",
            warn_only=True,
        )
    elif identifier is not None:
        url = f"/applications"
        params["identifier"] = identifier

    # Make static type checkers happy
    assert jg_ctx.client is not None

    stub = f"{id=}" if id is not None else f"{identifier=}"
    result = typing.cast(typing.Dict[str, typing.Any], make_request(
        jg_ctx.client,
        url,
        "GET",
        expected_status=200,
        abort_message=f"Couldn't retrieve application {stub} from API",
        support=True,
        params=params,
    ))
    render_single_result(
        jg_ctx,
        result,
        hidden_fields=HIDDEN_FIELDS,
        title="Application",
    )


@app.command()
@handle_abort
def create(
    ctx: typer.Context,
    name: str = typer.Option(
        ...,
        help=f"The name of the applicaion to create",
    ),
    identifier: typing.Optional[str] = typer.Option(
        None,
        help=f"The human-friendly identifier of the application. {IDENTIFIER_NOTE}",
    ),
    application_path: pathlib.Path = typer.Option(
        ...,
        help="The path to the directory where the application files are located",
    ),
    application_desc: typing.Optional[str] = typer.Option(
        None,
        help="A helpful description of the application",
    ),
):
    """
    Create a new application.
    """
    req_data = copy.deepcopy(JOBBERGATE_APPLICATION_CONFIG)
    req_data["application_name"] = name

    if identifier:
        req_data["application_identifier"] = identifier

    if application_desc:
        req_data["application_description"] = application_desc

    validate_application_files(application_path)

    req_data["application_config"] = dump_full_config(application_path)
    req_data["application_file"] = (application_path / JOBBERGATE_APPLICATION_MODULE_FILE_NAME).read_text()

